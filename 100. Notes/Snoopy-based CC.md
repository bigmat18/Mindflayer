**Data time:** 18:05 - 21-05-2025

**Status**: #note #youngling 

**Tags:** [[High Performance Computing]] [[Cache Coherence]]

**Area**: [[Master's degree]]
# Snoopy-based CC

In snoopy-based solutions, the [[Cache Coherence Abstract Architecture|GSK]] is coceptually **partitioned by columns**. Each **cache unit** (assuming only one cache per PE) acts as a **Local Controller (LC)**, containing the state of all the cache lines for what regards that PE/cache only (called **Local State Knowledge (LSK)**)

![[Pasted image 20250521181517.png]]

When a LC updates the state of a cache line in its LSK, some actions should happen to **atomically** update the state of the same cache line in all the other LSKs, which is done by the other LCs. This is because we need to change a whole **GSK entry** that is distributed among more PEs How to do that? We need a **centralization point**.

The architectural solutions is to use a bus (**Snoopy Bus**) to connect the LCs (ie, the PEs). The bus is accessed through an **arbiter**. Actually, other networks rather than buses can be used. 

Every time a PE executes a **LOAD with miss** or a **STORE**, it must obtain exclusive access to the bus. The request goes out and reply comes back without relinquishing the bus. Due to the bus serialization, snoopy-based solutions are often used for **single-CMP architectures** with **low parallelism**.

![[Pasted image 20250521182013.png | 400]]

All Local Controllers listen (snoop) to the bus requests. They can take actions both in response to local events generated by **local PE** or as as response to events from **remote PEs** snooped through the broadcast communication medium.

### [[Minimalistic Snoopy Protocol]]

### [[MSI Snoopy Protocol]]

### [[MESI Snoopy Protocol]]

### [[MOESI Snoopy Protocol]]


### Inclusive L2-L1 Hierarchy
This is easier for **inclusive caches**. C2 maintains a **dirty bit** per line, stating whether it is also present in its C1. Inclusion is not automatically guaranteed if C2 > C1. When C2 evicts a line (according to its replacement policy), this should be invalidated in C1 (if present). Furthermore, if C1 evicts a line, this should be notified to C2 to update.

**Example**. Assuming [[MESI Snoopy Protocol]]

![[Pasted image 20250522005142.png | 400]]

The line B is allocated in C2 and C1 of PE1
![[Pasted image 20250522005445.png | 400]]

The block B is modified in C1 of PE1. Transition from **Exclusive** to **Modified** (no access to the bus). The state became modified because the value in C2 is not updated. 
![[Pasted image 20250522005537.png | 400]]

The block B is forwarded from PE1s C1 to its C2 and to the C2/C1 of PE2. Memory is updated too (with [[MESI Snoopy Protocol]])
![[Pasted image 20250522005810.png | 400]]

### Non-bus Snoopy Coherence
Snopy-based CC does not strictly need a but to connect caches to the memory and together. It needs a **totally-ordered logical broadcasting of requests**. Any **request network** with totally ordered broadcasts works. **Response network** can be completely unordered. This is the main reason for the scalability limit of snoopy-based solutions, that fit how low-parallelism CMP.

![[Pasted image 20250522010824.png | 400]]

All messages first go to an ordering point, which then broadcasts the messages to all nodes in the system In addition to a bus, a **tree** can be another solution, with the root in charge of ordering requests. Also [[K-ary N-tori Networks (Tori)|rings]] can be adapted to this purpose, by collecting all requests in a specific node of the ring, which reorders and forwards them to all the nodes in broadcast Adapting on-chip networks to allow **totally ordered broadcast** is not easy.
# References